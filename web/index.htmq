!DOCTYPE = html
html {
    head {
        meta(http-equiv = content-type
             content    = 'text/html; charset=UTF-8')
        title = libxmq
        link(type = text/css
             href = resources/style.css
             rel  = stylesheet)
        link(type = text/css
             href = resources/xmq.css
             rel  = stylesheet)
        script(type = text/javascript
               src  = resources/code.js) = ''
        meta(name          = viewport
             content       = width=device-width
             initial-scale = 1.0)
    }
    body(onload='checkBackgroundSetting();')
    {
        h1 = 'XMQ - a new language for xml/html (+json)'
        i {
            'by Fredrik Öhrström (last updated '
            &DATE;
            ') oehrstroem@gmail.com'
        }
        br
        button(onClick = 'goDark();') = 'Dark Mode'
        ' '
        button(onClick = 'goLight();') = 'Light Mode'
        br
        p = 'The XMQ format is easier for a human to read and write than xml/html yet it
             captures exactly the xml/html content. It can always be safely pretty printed
             without introducing significant whitespace. The file-suffix htmq is used
             when working with html in the XMQ format. There is even a reasonable mapping
             between JSON and XMQ.'
        p {
            'You can use the standalone '
            a(href = https://github.com/libxmq/xmq/releases/latest)
            {
                i = xmq
            }
            ' tool to convert between xmq/xml/htmq/html/json  or include '
            a(href = https://github.com/libxmq/xmq/releases/latest) = xmq.h/xmq.c
            ' to use xmq directly from your program or in the future link to a prebuilt libxmq.'
        }
        div {
            a(href = https://github.com/libxmq/xmq/releases/latest) = '[Pre-built binaries]'
            &nbsp;
            &nbsp;
            a(href = https://github.com/libxmq/xmq) = [Github]
            &nbsp;
            &nbsp;
            a(href = xmq.pdf) = [Grammar]
            &nbsp;
            &nbsp;
            a(href = https://github.com/orgs/libxmq/discussions) = '[Forum/Discussions]'
            &nbsp;
            &nbsp;
            a(href = resources/index_htmq.html) = '[This page source as htmq]'
        }
        h2= Rationale
        p = 'XML can be human readable/editable if it is used for markup of longer
             human language texts, ie books, articles and other documents etc. In
             these cases the xml-tags represent a minor part of the whole xml-file.'
        p = 'However XML is often used for data storage and
             configuration files (eg pom.xml).  In such files the
             xml-tags represent a major part of the whole
             xml-file. This makes the data storage and config files
             hard to read and edit directly by hand. Today, the tags
             are a major part of html files as well, which is one
             reason why html files are hard to read and edit.'
        p = 'The other reason why XML/HTML is hard to edit by hand is because they
             have a complicated approach to dealing with significant
             whitespace. The truth is that you cannot always pretty print the
             XML/HTML code as you would like since it might introduce significant
             white space. In fact proper pretty printing even requires a full
             understanding of the DTD/XSD/CSS!'
        h2= Solution
        p {
            'XMQ solves the verbosity of tags by using braces to avoid
             closing xml-tags and parentheses to surround the
             attributes. XMQ solves the whitespace confusion by
             requiring all whitespace to be quoted.  There are a lot
             of details, of course, but let us begin with an example.'
         }
         p {
            'Download/build the xmq executable for your platform, then
             download: '
            &nbsp;
            a(href = resources/shiporder.xmq) = shiporder.xmq
            &nbsp;
            &nbsp;
            a(href = resources/shiporder.xml) = shiporder.xml
            ' (Note that the xml is manually pretty printed.)'
        }
        p {
            'To convert the XML to XMQ and pretty print with colors:'
            span(class = code) = 'xmq shiporder.xml'
        }
        p {
            'Use the pager command if the source file is large:'
            span(class = code) = 'xmq shiporder.xml pager'
            ' (Press q or esc to exit pager.)'
        }
        p {
            'Use shell redirection to store the XMQ output in a file:'
            span(class = code) = 'xmq shiporder.xml to-xmq > test.xmq'
            ' (The to-xmq command is the default command and can be left out here.)'
        }
        p {
            'To convert the XMQ to XML: '
            span(class = code) = 'xmq shiporder.xmq to-xml > test.xml'
        }
        &SHIPORDER_XMQ;
        ' '
        pre(class = 'xmq xmq_light w40')
        {
            &SHIPORDER_XML;
            &#10;
            &#10;
        }
        p = 'The hierarchical style should look familiar, but note:'
        ul {
            li = 'XMQ files are always UTF8 encoded.'
            li = 'Safe values after = can be stored as plain text (see 889923 container), no quoting needed!'
            li = '''Unsafe values (after =) with newlines, whitespace or ( ) { } ' " or leading = & // /* must be quoted.'''
            li = 'Two single quotes always mean the empty string (see sailing).'
            li = 'In multiline quotes, the incidental indentation is removed (see address).'
            li = ''''
            Quotes containing quotes are quoted using n+1 single quotes (see coord).
            Note that two quotes are reserved for the empty string. You will therefore see a single
            quote ' or three quotes ''' or more quotes.
            ''''
            li = 'Single line comments use // and multi line comments use /* */.'
            li = 'Comments containing comments are commented using n+1 slashes (eg ///* *///).'
        }
        p = 'This means that you can quote any block of text with enough single quotes and you
             can comment any block of text with enough slashes.'
        h2 = 'XMQ as a configuration file'
        p {
            'XMQ permits multiple root nodes which means that if you use XMQ as your software config file format
             then the first iteration of your config file can be as simple as this:'
            &nbsp;
            &nbsp;
            a(href = resources/config.xmq) = config.xmq
        }
        &CONFIG_XMQ;
        p = 'Every xmq file can be printed in compact form on a single line where whitespace between tokens is minimized.'
        &CONFIG_COMPACT_XMQ;
        p = 'The only permitted whitespace between tokens are space (ascii 32) and newlines (ascii 10 or 13 or 13 10).
             All other whitespace (including tabs) must be quoted. Let us take a look at shiporder in compact form.
             (Any linebreaks below are due to your browser.)'
        &SHIPORDER_COMPACT_XMQ;
        p = '''You can see character entities like &#10; for newlines and compound values address=('...'#10;'...')
               which normally is a multiline quote but where escaped newlines are intermingled with quotes to create the compact form.'''
        p = 'You can read the config file using a simple xmq api. (You can also use the full libxml2 api if you like.)'
        pre(class = 'xmq xmq_light w40') = 'XMQDoc *doc = xmqNewDoc();
                                            ok = xmqParseFile(doc, "config.xmq, "myconf"); assert(ok);
                                            server = xmqGetString(doc, NULL, "/myconf/server");
                                            port = xmqGetInt(doc, NULL, "/myconf/port");
                                            file = xmqGetString(doc, NULL, "/myconf/file");
                                            cron = xmqGetString(doc, NULL, "/myconf/cron");'
        p {
            'XMQ can be trivial which is nice for your first config file, but when your program
             grows in complexity, so can your config file. You do not have to convert your config
             file to xml, but if you want to then you can supply your implicit root (in this case myconf):'
            span(class = code) = 'xmq --root=myconf config.xmq to-xml > config.xml'
        }
        pre(class = 'xmq xmq_light w80') = &CONFIG_XML;
        h2= 'Web pages and whitespace'
        p {
            'Now let us try some htmq/html:'
            &nbsp;
            &nbsp;
            a(href = resources/welcome_traveller.htmq) = welcome_traveller.htmq
            &nbsp;
            &nbsp;
            a(href = resources/welcome_traveller.html) = welcome_traveller.html
            &nbsp;
            &nbsp;
            ' (Note that the html is manually pretty printed.)'
        }
        p {
            span(class = code) = 'xmq welcome_traveller.htmq pager'
        }
        &WELCOME_TRAVELLER_HTMQ;
        ' '
        pre(class = 'xmq xmq_light w80') = &WELCOME_TRAVELLER_HTML;
        ul {
            li = '''Text that does not immediately follow an equal sign = is called a standalone quote
                    (see 'Rest here ...' and 'p until ...') and must always be quoted.
                    If you do not quote them, they will be interpreted as elements (see html body a h1).'''
            li = 'XMQ pretty printing is straightforward whereas the html line breaks are weird to prevent spaces inside the word sleep.'
            li = 'XMQ entities like &nabla; (∇) must be outside of the quotes.'
            li = 'In the xmq it is obvious that there is exactly a single space between Say and the nabla.'
        }
        p {
            'If you convert from htmq to html:'
            span(class = code) = 'xmq welcome_traveller.htmq to-html'
            ' then you will see that xmq does not pretty print since it wants to preserve the xmq whitespace
             exactly as it was written. (Any linebreaks below are due to your browser.)
             Since you know exactly what whitespace you are feeding the browser (html) and other tools (xml)
             it will be easier to control their behaviour.'
        }
        pre(class = 'xmq xmq_light w40') = &WELCOME_TRAVELLER_NOPP_HTML;
        p {
            'If you convert from the original manually pretty printed html above to htmq:'
            span(class = code) = 'xmq welcome_traveller.html to-htmq'
            ' then you will see that the tool xmq by default trims
             whitespace using its own heuristic.  It keeps the
             original linebreaks but removes incidental indentation
             and leading/ending whitespace if they contain
             newlines. This usually work well but might in some
             situation remove significant spaces.'
        }
        &WELCOME_TRAVELLER_BACK_HTMQ;
        p {
            'You can also see that the &nabla; was replaced with the actual ∇. This happened because
             it was character entity, which is just another kind of quote.
             If you want to preserve all whitespace and restore the html entities then do:'
            span(class = code) = 'xmq --trim=none welcome_traveller.html to-htmq --escape-non-7bit'
        }
        &WELCOME_TRAVELLER_BACK_NOTRIM_HTMQ;
        p = 'As you can see there is quite a lot of whitespace in xml/html, which might or might not be
             significant/ignorable depending on your css and other settings. If you really want this whitespace then
             xmq will make it obvious.'
        h2= 'Compact XMQ with multiline comments'
        p {
            'The opposite of xmq pretty printing is xmq compact printing with no indentation and no newlines: '
            span(class = code) = 'xmq welcome_traveller.htmq to-htmq --compact'
        }
        &WELCOME_TRAVELLER_HTMQ_COMPACT;
        p {
            'Even multiline comments can be printed as compact XMQ since */* means a newline.
             This is not possible with XML since there is no standardized way to escape newlines inside html/xml comments.'
            &nbsp;
            &nbsp;
            a(href = resources/multi.xmq) = multi.xmq
        }
        &MULTI_XMQ;
        p {
            span(class = code) = 'xmq multi.xmq to-xmq --compact'
        }
        &MULTI_COMPACT_XMQ;
        ' '
        p {
            'Note that xml/html does not permit two dashes inside a comment!!! The xmq tool works around
             this by adding a very specific char (␐) in such a way there are no two consecutive dashes in the
             xml. When loading from such xml, the char (␐) is instead removed to restore the two dashes.'
            span(class = code) = 'xmq multi.xmq to-xml'
        }
        pre(class = 'xmq xmq_light w80') = &MULTI_XML;
        h2 = 'Quoting and entities inside attributes'
        p = '''For elements, a key=value is syntactic sugar for: key{'value'}
               However for attributes, this is not the case, here you can only write: key=value
               In the example below all elements and attributes have the content: 123'''
        &SYNTACTIC_SUGAR_XMQ;
        p {
            'XMQ is designed with the assumption that we rarely need significant leading/ending whitespace/quotes.
             However sometimes you have to have that. For an element value, you can express such whitespace in
             different ways:'
        }
        &CORNERS_XMQ;
        p = '''You can see the magenta colored parentheses ( after the equal = sign. This is a compound value
               consisting only of quotes and entities. Compound values are mandatory for the attribute values that
               need multiple quotes/entities since braces {} cannot be used inside an attribute value. '''
        &COMPOUND_XMQ;
        h2 = 'Viewing large html pages'
        p = 'The xmq tool is useful to decode large html pages. Let us assume that you downloaded a large html page: index.html'
        pre(class = 'xmq xmq_light w40')
        {
            'xmq index.html delete /html/head delete //style delete //script pager'
        }
        p = 'This command will delete the head node and all style and script nodes, before using the pager to show you the htmq.
             The argument to delete is an xpath expression.'
        p {
            'There are other commands to modify the xmq. In particular you can see how this web page is constructed by
             replacing entities with text files or with xmq files. '
             a(href = resources/index_htmq.html) = index.htmq
        }
        h2 = 'JSON'
        a(id=json)
        p {
            'We can use the xmq tool to convert shiporder to json:'
            span(class = code) = 'xmq shiporder.xmq to-json | jq .'
        }
        pre(class = 'xmq xmq_light w40')
        {
            &SHIPORDER_JSON;
        }
        p = 'If an XMQ value is a valid JSON number, true, false or null, then it is converted to
             the proper JSON value (without string quotes). If you want to force a number to a JSON string,
             then add the S attribute: speed(S) = 123'

        p { 'We can also use the xmq tool to parse json. '
            span(class = code) = '''curl -s 'https://dummyjson.com/todos?skip=4&limit=2' | xmq'''
            ' or '
            span(class = code) = 'xmq todos.json'
            &nbsp;
            &nbsp;
            a(href = resources/todos.xmq) = todos.xmq
            &nbsp;
            &nbsp;
            a(href = resources/todos.json) = todos.json

        }
        &TODOS_XMQ;
        ' '
        pre(class = 'xmq xmq_light w80')
        {
            &TODOS_JSON;
            &#10;
        }

        p = 'You can see that the unnamed JSON objects are given a single underscore _ as their name.'

        h2 = 'XSLT transforms'

        p = 'The XMQ format makes XSLT transforms readable! If you try to pretty print an xslt-transform you
             will get an output that is a mix of the desired whitespace and the implicit whitespace from
             the indented xslt-transforms. Again with XMQ this problem goes away.'

        h2 = 'Conclusions'
        p = 'With XMQ the assumed dichotomy between mark-up languages (like XML) and key-value store languages (like JSON)
             has been (perhaps surprisingly) removed. We can now use XML for mark-up situations and XMQ for key-value
             store situations. They are interchangeable and all the years of effort going into XSLT/XSD and other
             tools can still be used with XMQ.'

        p = 'There are of course still bugs to fix in xmq and improvements to how the specification works.
             Please let me know if you find bugs or other improvements.'
    }
}
