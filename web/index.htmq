!DOCTYPE = html
html {
    head {
        meta(http-equiv=content-type content='text/html; charset=UTF-8')
        title = libxmq
        link(type=text/css href=resources/style.css rel=stylesheet)
        link(type=text/css href=resources/xmq.css rel=stylesheet)
        script(type=text/javascript src=resources/code.js) = ''
        meta(name=viewport content='width=device-width' initial-scale=1.0)
    }
    body(onLoad='goDark();') {
        h1 = 'XMQ - a new language for xml/html (+json)'
        i {
            'by Fredrik Öhrström (last updated '
            &DATE;
            ') oehrstroem@gmail.com'
        }
        br
        button(onClick='goDark();') = 'Dark Mode'
        ' '
        button(onClick='goLight();') = 'Light Mode'
        br
        p = 'The XMQ format is easier for a human to read and write than xml/html yet it
             captures exactly the xml/html content. It can always be safely pretty printed
             without introducing significant whitespace. The file-suffix htmq is used
             when working with html in the XMQ format. There is even a reasonable mapping
             between JSON and XMQ.'
        p {
          'You can use the standalone '
          a(href=https://github.com/libxmq/xmq/releases/latest) { i = xmq }
          ' tool to convert between xmq/xml/htmq/html/json '
          ' or include '
          a(href=https://github.com/libxmq/xmq/releases/latest) = xmq.h/xmq.c
          ' to use xmq directly from your program or in the future link to a prebuilt libxmq.'
        }
        div {
            a(href=https://github.com/libxmq/xmq/releases/latest) = '[Pre-built binaries]'
            &nbsp;&nbsp;
            a(href=https://github.com/libxmq/xmq) = [Github]
            &nbsp;&nbsp;
            a(href=xmq.pdf) = [Grammar]
            &nbsp;&nbsp;
            a(href=api/index.html) = '[xmq.h API]'
        }
        p = 'XML can be human readable/editable if it is used for markup of longer
             human language texts, ie books, articles and other documents etc. In
             these cases the xml-tags represent a minor part of the whole xml-file.'

        p = 'However XML is often used for data storage and
             configuration files (eg pom.xml).  In such files the
             xml-tags represent a major part of the whole
             xml-file. This makes the data storage and config files
             hard to read and edit directly by hand. Today, the tags
             are a major part of html files as well, which is one
             reason why html files are hard to read and edit.'

        p = 'The other reason why XML/HTML is hard to edit by hand is because they
             have a complicated approach to dealing with significant
             whitespace. The truth is that you cannot always pretty print the
             XML/HTML code as you would like since it might introduce significant
             white space. In fact proper pretty printing even requires a full
             understanding of the DTD/XSD/CSS!'

        p { 'XMQ solves the verbosity of tags by using braces to avoid
             closing xml-tags and parentheses to surround the
             attributes. XMQ solves the whitespace confusion by
             requiring all whitespace to be quoted.  There are a lot
             of details, of course, but let us begin with an example.
             Download/build the xmq executable for your platform, then
             download: '
            &nbsp;
            a(href=resources/shiporder.xmq)=shiporder.xmq
            &nbsp;
            &nbsp;
            a(href=resources/shiporder.xml)=shiporder.xml
            ' (Note that the xml is manually pretty printed.)'
        }
        p {
          'To convert the XML to XMQ and pretty print with colors:'
          span(class=code) = 'xmq shiporder.xml'
        }
        p {
          'Use the pager command if the source file is large:'
          span(class=code) = 'xmq shiporder.xml pager'
          ' (Press q or esc to exit pager.)'
        }
        p {
          'Use shell redirection to store the XMQ output in a file:'
          span(class=code) = 'xmq shiporder.xml to-xmq > test.xmq'
          ' (The to-xmq command is the default command and can be left out here.)'
        }
        p {
          'To convert the XMQ to XML: '
          span(class=code) = 'xmq shiporder.xmq to-xml > test.xml'
        }
        &SHIPORDER_XMQ;
        ' '
        pre(class = 'xmq xmq_light w40')
        {
            &SHIPORDER_XML;
            &#10;
            &#10;
        }
        p = 'The hierarchical style should look familiar, but note:'
        ul{
            li = 'Safe values after = can be stored as plain text (see 889923 container), no quoting needed!'
            li = '''Unsafe values (after =) with newlines, whitespace or ( ) { } ' " or leading = & // /* must be quoted.'''
            li = 'Two single quotes always mean the empty string (see sailing).'
            li = 'In multiline quotes, the incindental indentation is removed (see address).'
            li = ''''Quotes containing quotes are quoted using n+1 single quotes (see coord). Note that two quotes are reserved for the empty string. You will therefore see a single quote ' or three quotes ''' or more quotes.''''
            li = 'Single line comments use // and multi line comments use /* */.'
            li = 'Comments containing comments are commented using n+1 slashes (eg ///* *///).'
        }
        p = 'This means that you can quote any block of text with enough single quotes and you
             can comment any block of text with enough slashes.'

        p = 'XMQ permits multiple root nodes which means that if you use XMQ as your software config file format
             then the first iteration of your config file can be as simple as this:'
        &CONFIG_XMQ;
        ' '
        pre(class = 'xmq xmq_light w40')
        {
            'XMQDoc *doc = xmqNewDoc();
             ok = xmqParseFile(doc, "config.xmq, "myconf"); assert(ok);
             server = xmqGetString(doc, NULL, "/myconf/server");
             port = xmqGetInt(doc, NULL, "/myconf/port");
             file = xmqGetString(doc, NULL, "/myconf/file");
             cron = xmqGetString(doc, NULL, "/myconf/cron");'
        }
        p { 'The advantage of using XMQ instead of a hand coded format (often similar to INI), becomes obvious when
             your software evolves. If you use XMQ, then you can rest assure that your config file is future proof
             since you can always move on to more powerful XMQ constructs if you need to. When you use XMQ as a config file,
             you do not have to convert it to XML, but if you really want to convert a root-less XMQ file to a valid
             XML file, then you can supply your implicit root (in this case myconf):'
            span(class=code) = 'xmq --root=myconf config.xmq to-xml > config.xml'
        }
        pre(class = 'xmq xmq_light w80')
        {
            &CONFIG_XML;
        }

        p {
            'Now let us try some htmq/html:'
            &nbsp;
            &nbsp;
            a(href=resources/welcome_traveller.htmq)=welcome_traveller.htmq
            &nbsp;
            &nbsp;
            a(href=resources/welcome_traveller.html)=welcome_traveller.html
            &nbsp;
            &nbsp;
            ' (Note that the html is manually pretty printed.)'
        }
        p {
          span(class=code) = 'xmq welcome_traveller.htmq pager'
        }
        &WELCOME_TRAVELLER_HTMQ;
        ' '
        pre(class = 'xmq xmq_light w80')
        {
            &WELCOME_TRAVELLER_HTML;
        }
        ul {
            li = '''Text that does not immediately follow an equal sign = is called a standalone quote
                    (see 'Rest here ...' and 'p until ...') and must always be quoted.
                    If you do not quote them, they will be interpreted as elements (see html body a h1).'''
            li = 'XMQ pretty printing is straightforward whereas the html line breaks are weird to prevent spaces inside the word sleep.'
            li = 'XMQ entities like &nabla; (∇) must be outside of the quotes.'
            li = 'In the xmq it is obvious that there is exactly a single space between the dot and the nabla.'
        }
        p {
          'If you convert from htmq to html:'
          span(class=code) = 'xmq welcome_traveller.htmq to-html'
          ' then you will see that xmq currently does not pretty print since
            it wants to preserve the xmq whitespace exactly as it was written. (Any linebreaks below are due to the browser.)
            Since you know exactly what whitespace you are feeding the browser (html) and other tools (xml)
            it will be easier to control their behaviour.'
        }
        pre(class = 'xmq xmq_light w40')
        {
            &WELCOME_TRAVELLER_NOPP_HTML;
        }
        p { 'If you convert from the original manually pretty printed html above to htmq:'
             span(class=code) = 'xmq welcome_traveller.html to-htmq'
            'then you will see that the tool xmq by default trims whitespace using its own heuristic.
             It keeps the original linebreaks but remove leading/ending whitespace if they
             contain newlines. This usually work well but might in some situation remove
             significant spaces.'
        }
        p { 'You can also see that the &nabla; was replaced with the actual ∇. This happened because
             it was character entity, which is just another kind of quote.
             If you want to preserve all whitespace and restore the html entities then do:'
             span(class=code) = 'xmq --trim=none welcome_traveller.html to-htmq --escape-non-7bit'
        }
        &WELCOME_TRAVELLER_BACK_HTMQ;
        ' '
        &WELCOME_TRAVELLER_BACK_NOTRIM_HTMQ;
        p = 'As you can see there is quite a lot of whitespace in xml/html, which might or might not be
             significant/ignorable depending on your css and other settings. If you really want this whitespace then
             xmq will make it obvious.'
        p {
          'The opposite of xmq pretty printing is xmq compact printing with no indentation and no newlines: '
          span(class=code) = 'xmq welcome_traveller.htmq to-htmq --compact'
        }
        &WELCOME_TRAVELLER_HTMQ_COMPACT;
        p {
            'And another simple data structure.'
            &nbsp;
            &nbsp;
            a(href=resources/car.xmq)=car.xmq
            &nbsp;
            &nbsp;
            a(href=resources/car.xml)=car.xml
        }
        &CAR_XMQ;
        ' '
        pre(class = 'xmq xmq_light w40')
        {
            &CAR_XML;
        }
        ul {
            li {
                '''Note: key=value is just a syntatic sugar for: key{'value'}'''
                &nbsp;
                &nbsp;
                a(href=resources/sugar.xmq)=sugar.xmq
            }
        }
        p = 'All the chairs below have the same value: 123. Remember that leading/ending whitespace is trimmed from quotes.
             But the chaise has a leading space and 3 ending space.'
        pre(class = 'xmq xmq_light w40')
        {
            &SUGAR_XMQ;
        }
        p {
          span(class=code) = 'xmq sugar.xmq to-xml'
        }
        pre(class = 'xmq xmq_light w40')
        {
            &SUGAR_XML;
        }
        p {
          'An xmq file can always be printed on a single line, without newlines: '
          span(class=code) = 'xmq shiporder.xml to-xmq --compact'
        }
        &SHIPORDER_XMQ_COMPACT;
    }
}
